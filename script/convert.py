"""
    Author: Prof.Hannes Rost
This script converts the input library generated by DIAUmpire to an OpenSWATH
library using several possible decoy options:

    - "randFragments" (random fragments)
    - "randRT" (random retention time)
    - "randMZ" (random m/z)
    - "randSWATH" (random SWATH)


usage: 
    convert.py inputfile outputfile decoy_option

"""

import csv
from pyteomics import mass
import random

csvheader=[
"PrecursorMz",
"ProductMz",
"Tr_recalibrated",
"transition_name",
"CE",
"LibraryIntensity",
"transition_group_id",
"decoy",
"PeptideSequence",
"ProteinName",
"CompoundName",
"SumFormula",
"PrecursorCharge",
"LabelTyp", 
"Qual_samples", 
"Qual_isotopes", 
"Qual_spectra", 
]

cnt = 1
cnt_trgr = 1
RT_MINDIST = 160

def process_stack_mapping(stack, mapping):
    assert len(stack) > 7
    header = stack[:7]
    fragments = stack[7:]
    nr_samples = stack[3].split(":")[1].split("/")[0]
    nr_isotopes = stack[5].split(":")[1]
    nr_spectra = stack[6].split(":")[1]
    sumformula = header[0].split(": ")[1]
    charge = int(header[1].split(": ")[1])
    rt = float(header[2].split(": ")[1])
    precursor_mz = abs(mass.calculate_mass(formula=sumformula, charge=charge))
    #
    swath_window = int((precursor_mz - 100 ) / 25)
    #
    # print precursor_mz, sumformula, swath_window
    frions = mapping.get(swath_window, [])
    for f in fragments:
        mz, inten = f.split("\t")
        mz = float(mz)
        frions.append(mz)
    mapping[swath_window] = frions


def process_stack(stack, topN, mapping, decoy_method="randRT"):
    assert len(stack) > 7
    global cnt, cnt_trgr
    header = stack[:7]
    fragments = stack[7:]
    nr_samples = stack[3].split(":")[1].split("/")[0]
    nr_isotopes = stack[5].split(":")[1]
    nr_spectra = stack[6].split(":")[1]
    sumformula = header[0].split(": ")[1]
    charge = int(header[1].split(": ")[1])
    rt = float(header[2].split(": ")[1])
    precursor_mz = abs(mass.calculate_mass(formula=sumformula, charge=charge))
    #
    swath_window = int((precursor_mz - 100 ) / 25)
    #
    res = []
    tmpres = []
    curr_ions = []
    for f in fragments:
        mz, inten = f.split("\t")
        mz = float(mz)
        curr_ions.append(mz)
        tmpres.append([
            precursor_mz,
            mz,
            rt,
            "%s_%s"  % (cnt, sumformula),
            -1,
            inten,
            "%s_%s"  % (cnt_trgr, sumformula), # transition_group_id
            0, # decoy
            "", # sum-formula
            "", # protein name
            sumformula,
            sumformula,
            charge,
            "light", 
            nr_samples, nr_isotopes, nr_samples]
        )
        cnt += 1
    cnt_trgr += 1
    # Sort by intensity
    tmpres.sort(lambda x,y: -cmp( float(x[5]), float(y[5])))
    if topN:
        tmpres = tmpres[:topN]
    res.extend(tmpres)

    ## Decoy RT
    tmpres = []
    newrt = float(rt)
    while abs(newrt - rt) < RT_MINDIST:
        # shift by +/- 300 seconds
        newrt = newrt + ((random.random()) -0.5) * 600
        if newrt < 0 or newrt > 1300:
            newrt = rt

    ## Decoy fragments
    ## select N fragment ions that dont overlap
    frnew = []
    tries = 0
    while len(frnew) < len(curr_ions):
        frions = mapping[swath_window]
        fr_idx = int(random.random() * len(frions))

        # Check for overlap with (i) target and (ii) current decoy
        overlap = False
        for ion in curr_ions:
            if abs(ion - frions[fr_idx]) < 0.1:
                overlap = True
        for ion in frnew:
            if abs(ion - frions[fr_idx]) < 0.1:
                overlap = True

        # append now
        if not overlap:
            frnew.append(frions[fr_idx])
        if tries > 1000:
            # no decoy possible
            return res
        tries += 1

    print "current precursor", precursor_mz, sumformula
    print "current target fragment ions", curr_ions
    print "new decoy fragment ions", frnew

    prec_shift = 0.00001
    if decoy_method == "randFragments":
        decoy_fragments = frnew
        decoy_rt = rt
    elif decoy_method == "randRT":
        decoy_fragments = curr_ions
        decoy_rt = newrt
    elif decoy_method == "randMZ":
        decoy_fragments = curr_ions
        decoy_rt = rt
        for k in range(len(decoy_fragments)):
            decoy_fragments[k] = decoy_fragments[k] + (random.random()-0.5) * 3.0
    elif decoy_method == "randSWATH":
        decoy_fragments = curr_ions
        decoy_rt = rt
        prec_shift = 35

    for k,f in enumerate(fragments):
        mz, inten = f.split("\t")
        mz = float(decoy_fragments[k])
        tmpres.append([
            precursor_mz + prec_shift,
            mz,
            decoy_rt,
            "DECOY_%s_%s"  % (cnt, sumformula),
            -1,
            inten,
            "DECOY_%s_%s"  % (cnt_trgr, sumformula), # transition_group_id
            1, # decoy
            "", # sum-formula
            "", # protein name
            sumformula,
            sumformula,
            charge,
            "light", 
            nr_samples, nr_isotopes, nr_samples]
        )
        cnt += 1
    cnt_trgr += 1
    # Sort by intensity
    tmpres.sort(lambda x,y: -cmp( float(x[5]), float(y[5])))
    if topN:
        tmpres = tmpres[:topN]
    res.extend(tmpres)

    return res


import sys

inp = sys.argv[1]
outp = sys.argv[2]
decoy_method = sys.argv[3]

f = open(inp)

stack = []
mapping = {}
for line in f:
    if line.startswith("Formula"):
        if len(stack) != 0:
            q = process_stack_mapping(stack, mapping)
            stack = []
    stack.append(line.strip())

f.close()

for k,v in mapping.iteritems():
    print k


f = open(inp)
fout = open(outp, "w")
out = csv.writer(fout, delimiter = '\t')
out.writerow(csvheader)
stack = []
for line in f:
    if line.startswith("Formula"):
        if len(stack) != 0:
            q = process_stack(stack, 6, mapping, decoy_method)
            for qq in q:
                out.writerow(qq)
            stack = []

    stack.append(line.strip())


# for k,v in mapping.iteritems():
#     print k,v
# 
